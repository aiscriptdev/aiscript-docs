ai:
  - title: Prompt
    description: "`prompt` is a keyword that allows you to interact with the AI model. It supports both simple and advanced syntax with customizable parameters."
    codeDemos:
      - code: |
          // Simple prompt usage
          let answer = prompt "What is the capital of France?";
          print(answer); // Paris

          // Advanced syntax with model configuration
          let detailed_answer = prompt "Explain quantum computing" => {
              model: "gpt-4",
              max_tokens: 500,
              temperature: 0.7,
              system_prompt: "You are a quantum physics expert"
          };
          print(detailed_answer);
        filename: prompt.ai
  - title: AI Function
    description: "`ai fn` is a powerful keyword that allows you to define AI-powered functions with type safety and reusability."
    codeDemos:
      - code: |
          // Define an AI function for sentiment analysis
          ai fn analyze_sentiment(text: str) -> float {
              let sentiment = prompt "Analyze the sentiment of this text and return a score between -1 and 1: {text}";
              return float(sentiment);
          }

          // Use the AI function
          let review = "This product is amazing! Best purchase ever!";
          let score = analyze_sentiment(review);
          print(score); // 0.9
        filename: ai_function.ai
  - title: Agent
    description: "`agent` is native concept of the language, use `agent` keyword to define the agent, specify the instructions, declare the functions as the tools.\n The multi-agent orchestration is inspired by https://github.com/openai/swarm"
    codeDemos:
      - code: |
          let player1_move = nil;
          let player2_move = nil;
          agent Judge {
            instructions: "You are the judge of the Rock Paper Scissors game.
            1. Let Player1 move first then Player2
            2. Use record_move to store each player's move after it finished
            3. After both players finished, use announce_result to display the result
            4. End the game after announcing results",
            fn record_move(player: str, move: str) {
              """Record a player's move."""
                  print(player, "choose", move);
                  if player == "Player1" {
                      player1_move = move;
                  } else {
                      player2_move = move;
                  }
              }
              fn announce_result() {
                  """Check the recorded moves and announce the winner."""
                  let winning_moves = {"rock": "scissors", "scissors": "paper", "paper": "rock"};
                  if player1_move == player2_move {
                      print("It's a tie!");
                  } else if winning_moves[player1_move] == player2_move {
                      print("Player 1 wins!");
                  } else {
                      print("Player 2 wins!");
                  }
              }
              fn transfer_to_player1() {
                  """Transfer control to Player 1 Agent"""
                  return Player1;
              }
              fn transfer_to_player2() {
                  """Transfer control to Player 2 Agent"""
                  return Player2;
              }
          }
        filename: judger.ai
      - code: |
          use std.random;
          
          fn make_move() -> str {
              """Make a move in the game. Returns rock, paper, or scissors."""
              return random.choice(["rock", "paper", "scissors"]);
          }
          fn transfer_to_judge() {
              """Transfer control to Judge Agent"""
              return Judge;
          }
          agent Player1 {
              instructions: "You are Player 1 in the Rock Paper Scissors game.
              1. Make your move using the make_move function
              2. Transfer control to the judge after your move",
              tools: [make_move, transfer_to_judge],
          }
          agent Player2 {
              instructions: "You are Player 2 in the Rock Paper Scissors game.
              1. Make your move using the make_move function
              2. Transfer control to the judge after your move",
              tools: [make_move, transfer_to_judge],
          }
        filename: player.ai
      - code: |
          Judge.run(input="Let's start play the game!", debug=true);
          // Here are the logs:
          //
          // Judge call transfer_to_player1()
          // Player1 call make_move(): scissors
          // Player1 call transfer_to_judge()
          // Judge call record_move(Player1, scissors)
          // Judge call transfer_to_player2()
          // Player2 call make_move(): paper
          // Player2 call transfer_to_judge()
          // Judge call record_move(Player2, paper)
          // Judge call announce_result(): Player 1 wins!
        filename: main.ai
      - code: |
          OPENAI_API_KEY=put-your-openapi-key-here
        filename: .env

web:
  - title: Route DSL
    description: "Define web routes with a simple and intuitive DSL that supports AI-powered endpoints and type-safe request/response handling."
    codeDemos:
      - code: |
          get /repo {
              """Repo API"""

              query {
                  """repo name"""
                  @string(min_len=3, max_len=30)
                  name: str
              }

              return "repo: " + name;
          }
        filename: get.ai
      - code: |
          post /repo {
              """Create a repository"""

              // Replace @json with @form to parse body from form
              @json
              body {
                  """The repository name"""
                  @string(min_len=3, max_len=30)
                  name: str
              }

              return "create repo: " + name;
          }
        filename: post.ai
      - code: |
          put /repo/<id:int> {
              """Update a repository"""

              @json
              body {
                  """The repository name"""
                  @string(min_len=3, max_len=30)
                  name: str
              }

              return "update repo: " + name;
          }
        filename: put.ai
      - code: |
          delete /repo/<id:int> {
              """Delete a repository"""

              return "delete repo: " + id;
          }
        filename: delete.ai
  - title: Validator
    description: "Built-in request validation with type checking and custom validation rules for secure API endpoints."
    codeDemos:
      - code: |
          post /api/user {
              // Request body validation
              @json
              body {
                  @string(min_length: 3, max_length: 20)
                  username: str,
                  @format(type="email")
                  email: str,
                  @number(min=18)
                  age: int,
              }

              // Body is already validated
              // Insert user into users table...
              return "User created successfully";
          }
        filename: validator.ai
      - code: |
          $ curl -X POST -X POST http://localhost:8080/api/user \
              -H 'Content-Type: application/json' \
              -d '{
                  "username": "john_doe",
                  "email": "johndoe@gmail.com",
                  "age": 17
              }'

          {
            "error": "ValidationError",
            "message": "Invalid request body",
            "details": [
              {
                "field": "age",
                "message": "Value must be greater than or equal to 18"
              }
            ]
          } 
          $ curl -X POST -X POST http://localhost:8080/api/user \
              -H 'Content-Type: application/json' \
              -d '{
                  "username": "john_doe",
                  "email": "johndoe@gmail.com",
                  "age": 25
              }'
           User created successfully 
        filename: curl
  - title: OpenAPI
    description: "Automatic OpenAPI documentation generation from your route definitions with full type information and examples."
    codeDemos:
      - code: |
          post /api/chat {
              """Use triple-quotes for OpenAPI documentation"""

              body {
                  """Field also supports OpenAPI docs"""
                  message: str,
              }

              return "Input: " + body.message + "!";
          }
        filename: openapi.ai
      - img: /toucan.png
        filename: openapi.png
  - title: Effortless Auth and Social Login
    description: "Integrate social login providers with minimal configuration and type-safe authentication flows."
    codeDemos:
      - code: |
          // JWT auth
          @auth
          get /ask {
              query {
                  @string(min_len=5, max_len=50)
                  question: str
              }

              ai fn ask_llm(question: str) -> str {
                  return prompt question;
              }
              let answer = ask_llm(query.question);
              return answer;
          }
        filename: jwt_auth.ai
      - code: |
          // Username/Password auth
          @basic_auth
          post /guess {
              body {
                  @number(min=1, max=100)
                  magic: int = 1
              }
              
              header.path = "/guess";
              let msg = "Try again!";
              if body.magic == 42 {
                  msg = "You guessed it!";
              }
              return {
                  body: msg,
                  headers: {
                      path: "/guess",
                  }
              };
          }
        filename: basic_auth.ai
      - code: |
          @sso(provider="google")
          get /auth/google {
              let url = sso.authority_url();
              print(url);
              return temporary_redirect(target=url);
          }

          @sso(provider="google")
          get /auth/google/callback {
              query {
                  code: str,
                  state: str,
              }

              print("code", query.code);
              print("state", query.state);
              let user_info = sso.verify(code=query.code);
              print(user_info);
              return { user_info };
          }
        filename: google_login.ai
      - code: |
          [auth.jwt]
          secret = "$JWT_SECRET"
          expiration = 3600

          [auth.basic]
          username = "admin"
          password = "123456"

          [sso.google]
          client_id = "123"
          client_secret = "abc"
          redirect_url = "http://localhost:8080/auth/google/callback"
          scopes = ["email"]
        filename: project.toml

language:
  - title: Enum
    description: "Enums in AIscript provide a way to define a type that can be one of several variants, with full type safety and pattern matching support."
    codeDemos:
      - code: |
          enum Status {
            Pending   = 1,
            Active    = 2, 
            Suspended = 3,
          }
          fn process_status(status: Status) {
              match status {
                  Status::Pending => print("Pending"),
                  Status::Active => print("Active"),
                  Status::Suspended => print("Suspended"),
              }
          }
          print(process_status(Status::Active)); // expect: Status::Active(1)
        filename: enum.ai
      - code: |
          enum Status {
            Pending   = 1,
            Active    = 2, 
            Suspended = 3,
          }
          // use [Enum::Variant] syntax to evaluate
          // the value of variant
          print([Status::Active]); // expect: 1
        filename: evaluate_enum.ai
  - title: Lambda
    description: "The lambda syntax allows for concise and expressive function definitions, capturing variables from the outer scope."
    codeDemos:
      - code: |
          // Lambda capturing variables from outer scope
          let multiplier = 2;
          let times = |x| x * multiplier;
          print(times(4)); // expect: 8
          multiplier = 3;
          print(times(4)); // expect: 12

          // Passing lambda as argument
          fn apply(f, x) {
              return f(x);
          }
          print(apply(|x| x * x, 3)); // expect: 9
        filename: lambda.ai
  - title: Pipe Operator
    description: "The pipe operator (|>) allows for clean and readable function chaining, making data transformation more intuitive."
    codeDemos:
      - code: |
          // Data processing pipeline example
          let data = [1, 2, 3, 4, 5]
              |> map(fn(x) => x * 2)
              |> filter(fn(x) => x > 5)
              |> reduce(fn(acc, x) => acc + x, 0);

          // Text processing pipeline
          let text = "Hello, World!"
              |> str.to_lower()
              |> str.replace(" ", "_")
              |> str.trim();
        filename: pipe.ai
  - title: Error handling
    description: "AIscript provides robust error handling with typed errors and elegant error propagation using the raise keyword."
    codeDemos:
      - code: |
          // Define custom error types
          class ValidationError! {
              field: str,
              message: str,
          }

          fn validate_user(user: map) -> bool | ValidationError! {
              if !user.has_key("email") {
                  raise ValidationError! {
                      field: "email",
                      message: "Email is required"
                  };
              }
              return true;
          }
        filename: error.ai
      - code: |
          // Define custom error types
          class ValidationError! {
              field: str,
              message: str,
          }
        filename: error-propogation.ai

std-library:
  - title: Database
    description: "Built-in database operations with type-safe queries and migrations support."
    codeDemos:
      - code: |
          // Define a schema
          schema User {
              id: int @primary,
              name: str,
              email: str @unique,
              created_at: datetime @default(now())
          }

          // Type-safe database operations
          async fn create_user(name: str, email: str) -> User {
              let user = await db.User.create({
                  name: name,
                  email: email
              });
              return user;
          }
        filename: database.ai
  - title: Redis
    description: "Native Redis integration for caching and real-time data operations with type safety."
    codeDemos:
      - code: |
          // Configure Redis connection
          redis.connect({
              host: env.REDIS_HOST,
              port: env.REDIS_PORT
          });

          // Cache function results
          @cache(ttl: 3600)
          async fn get_user_data(id: int) -> map {
              let data = await db.users.find_by_id(id);
              return data;
          }

          // Pub/Sub example
          redis.subscribe("user_updates", fn(message) {
              print("Received update: {message}");
          });
        filename: redis.ai
  - title: Builtin functions
    description: "Rich set of built-in functions for common operations with consistent APIs and type safety."
    codeDemos:
      - code: |
          // String manipulation
          let text = "hello world";
          print(text.capitalize()); // Hello world
          print(text.split(" ")); // ["hello", "world"]

          // Array operations
          let numbers = [1, 2, 3, 4, 5];
          print(numbers.sum()); // 15
          print(numbers.average()); // 3
          print(numbers.map(fn(x) => x * 2)); // [2, 4, 6, 8, 10]

          // Date and time
          let now = datetime.now();
          print(now.format("YYYY-MM-DD")); // 2024-03-21
          print(now.add_days(7)); // 2024-03-28
        filename: builtin.ai